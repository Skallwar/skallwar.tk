<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>The unkillable process :: Skallwar.fr</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="A word on signals If you have already played with signals, chances are you might have tried to catch signals using the signal or sigaction syscalls. All signals can be caught except SIGKILL and SIGSTOP.
 The SIGKILL signal is used to cause immediate program termination. It cannot be handled or ignored, and is therefore always fatal. It is also not possible to block this signal. [&amp;hellip;] if SIGKILL fails to terminate a process, that by itself constitutes an operating system bug which you should report." />
<meta name="keywords" content=", " />
<meta name="robots" content="noodp" />
<link rel="canonical" href="/posts/unkillable_process/" />




<link rel="stylesheet" href="/assets/style.css">

  <link rel="stylesheet" href="/assets/green.css">






<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">

  <link rel="shortcut icon" href="/img/favicon/green.png">



<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="The unkillable process :: Skallwar.fr">
<meta property="og:description" content="Tired of having your process getting killed? Catching SIGINT and SIGTERM is not enough for you? What if you could catch **all** signals sent to your process..." />
<meta property="og:url" content="/posts/unkillable_process/" />
<meta property="og:site_name" content="The unkillable process" />

  <meta property="og:image" content="/">

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">


  <meta property="article:published_time" content="2021-04-22 00:00:00 &#43;0000 UTC" />












</head>
<body class="green">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    Skallwar.fr
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="/posts/unkillable_process/">The unkillable process</a></h1>
  <div class="post-meta">
    
      <span class="post-date">
        2021-04-22 
      </span>
    
    
    <span class="post-author">:: Skallwar</span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="/tags/ebpf/">eBPF</a>&nbsp;
    
    #<a href="/tags/linux/">linux</a>&nbsp;
    
  </span>
  

  

  

  <div class="post-content"><div>
        <h1 id="a-word-on-signals">A word on signals<a href="#a-word-on-signals" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>If you have already played with signals, chances are you might have tried to
catch signals using the
<a href="https://man7.org/linux/man-pages/man2/signal.2.html"><code>signal</code></a> or
<a href="https://man7.org/linux/man-pages/man2/sigaction.2.html"><code>sigaction</code></a> syscalls.
All signals can be caught except <code>SIGKILL</code> and <code>SIGSTOP</code>.</p>
<blockquote>
<p>The SIGKILL signal is used to cause immediate program termination. It cannot be handled or ignored, and is therefore always fatal. It is also not possible to block this signal. [&hellip;] if SIGKILL fails to terminate a process, that by itself constitutes an operating system bug which you should report.</p>
<p>&ndash; <!-- raw HTML omitted --><a href="https://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html">Termination Signals</a><!-- raw HTML omitted --></p>
</blockquote>
<blockquote>
<p>The SIGSTOP signal stops the process. It cannot be handled, ignored, or blocked.</p>
<p>&ndash; <!-- raw HTML omitted --><a href="https://www.gnu.org/software/libc/manual/html_node/Job-Control-Signals.html">Job Control Signals</a><!-- raw HTML omitted --></p>
</blockquote>
<p>But I don&rsquo;t want my process to die, I heard you say. Well if I can&rsquo;t catch them,
what do you want me to do? Kill the sender?</p>
<p>Actually I can&rsquo;t kill the sender, but what if I could intercept and drop the
message&hellip;</p>
<h1 id="meet-ebpf">Meet eBPF<a href="#meet-ebpf" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<blockquote>
<p>The Linux kernel has always been an ideal place to implement
monitoring/observability, networking, and security. Unfortunately this was
often impractical as it required changing kernel source code or loading kernel
modules, and resulted in layers of abstractions stacked on top of each other.
eBPF is a revolutionary technology that can run sandboxed programs in the
Linux kernel without changing kernel source code or loading kernel modules.</p>
<p>By making the Linux kernel programmable, infrastructure software can leverage
existing layers, making them more intelligent and feature-rich without
continuing to add additional layers of complexity to the system or
compromising execution efficiency and safety.</p>
<p>&ndash; <!-- raw HTML omitted --> <a href="https://ebpf.io/">eBPF</a> <!-- raw HTML omitted --></p>
</blockquote>
<p>eBPF is used to expand the Linux kernel by allowing user space program to
inject some code into hook points. The code is JIT compiled and executed if
there is no error raised by the verification engine.</p>
<h1 id="blocking-some-signals">Blocking some signals<a href="#blocking-some-signals" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>My idea was as simple as blocking the signal, this way it will never reach our
protected process. In order to do so, I tried to catch the signal as early as
possible in the kernel: when a process uses the <a href="https://man7.org/linux/man-pages/man2/kill.2.html"><code>kill</code></a>
syscall.</p>
<p>To quickly see if the idea was really possible, I used <a href="https://github.com/iovisor/bpftrace">bpftrace</a>,
a high-level tracing language for eBPF.</p>
<p>Fortunately, all syscalls have a <a href="https://www.kernel.org/doc/Documentation/kprobes.txt"><code>kprobe</code></a>
hook point for eBPF. The goal here is to filter out signals for our protected
process and discard them. In order to discard them, I will use the
<code>override()</code> <code>bpftrace</code> method which will abort the probed function an will return the return
code provided in argument. This functionality requires that your kernel was
compiled with <code>CONFIG_BPF_KPROBE_OVERRIDE</code> and only works on functions with the
<code>ALLOW_ERROR_INJECTION</code> tag. Fortunately Arch Linux&rsquo;s kernel already comes
with <code>CONFIG_BPF_KPROBE_OVERRIDE</code> enabled, and every syscall handler seems to
have the <code>ALLOW_ERROR_INJECTION</code> tag on them.</p>
<p>So here is a <a href="https://github.com/Skallwar/blocksig/blob/main/blocksig.sh">script</a>
to block all signals to your process:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/bin/sh
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;</span>$#<span style="color:#e6db74">&#34;</span> -ne <span style="color:#ae81ff">1</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
    echo <span style="color:#e6db74">&#34;Usage: </span>$0<span style="color:#e6db74"> pid&#34;</span>
    exit <span style="color:#ae81ff">1</span>
<span style="color:#66d9ef">fi</span>

<span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;</span>$EUID<span style="color:#e6db74">&#34;</span> -ne <span style="color:#ae81ff">0</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
    echo <span style="color:#e6db74">&#34;Please run as root&#34;</span>
    exit <span style="color:#ae81ff">1</span>
<span style="color:#66d9ef">fi</span>

bpftrace -e <span style="color:#e6db74">&#34;kprobe:__x64_sys_kill { if (arg1 == </span>$1<span style="color:#e6db74">) { printf(\&#34;Signal blocked for </span>$1<span style="color:#e6db74">\n\&#34;); override(0); } }&#34;</span> --unsafe
</code></pre></div><p>Let&rsquo;s take an example:</p>
<pre><code class="language-terminal" data-lang="terminal">$ # Without blocksig.sh
$ ping skallwar.fr &gt; /dev/null &amp;
[1] 371628
$ kill -9 371628
[1]+  Killed                  ping skallwar.fr &gt; /dev/null

$ # With blocksig.sh
$ ping skallwar.fr &gt; /dev/null &amp;
[1] 315629
$ sudo ./blocksig.sh 315629 &amp;
Attaching 1 probe...
$ kill -9 315629
Signal blocked for 315629
</code></pre><p>As you can see, the second time around, our ping did not get killed. We actually
blocked a <code>SIGKILL</code>.</p>
<p>As a side note, the first time I launched <code>blocksig.sh</code>, I did not filter on the
pid before calling <code>override()</code>. As a side effect, <code>systemctl</code> refused to either
<code>poweroff</code> or <code>reboot</code> my machine.</p>
<p>This technique works fine but we just moved the problem elsewhere. Now our process
is protected but our <code>blocksig.sh</code> is not. If someone kills <code>blocksig.sh</code>, our
process is defenseless and we are back to square one. You might think that using
<code>$$</code>, the shell special variable for pid will do the trick but remember, this
is the pid of the shell <strong>not</strong> the pid of the <code>bpftrace</code> command.</p>

  <figure class="left" >
    <img src="images/blocksig_sh_block_shell_pid_problem.png"   />
    
  </figure>


<p>We need to setup the &ldquo;fence&rdquo; from the inside&hellip;</p>
<h1 id="bcc-to-the-rescue">BCC to the rescue<a href="#bcc-to-the-rescue" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>To fix our problem I used <a href="https://github.com/iovisor/bcc">BCC</a>. BCC is a
toolkit for creating efficient kernel tracing and manipulation programs using
eBPF and Python.</p>
<p>Here is what a basic <a href="https://github.com/iovisor/bcc/blob/master/examples/hello_world.py">hello world</a> looks like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#!/usr/bin/python</span>

<span style="color:#f92672">from</span> bcc <span style="color:#f92672">import</span> BPF

BPF(text<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;int kprobe__sys_kill(void *ctx) { bpf_trace_printk(&#34;Hello, World!</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">n&#34;); return 0; }&#39;</span>)<span style="color:#f92672">.</span>trace_print()
</code></pre></div><p>So we write some C code as a string inside our Python script&hellip; Weird but why not ?
You can also load from a file like so:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">syscall_kill</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ctx) {
    bpf_trace_printk(<span style="color:#e6db74">&#34;Hello, World!</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">n&#34;</span>); 
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#!/usr/bin/python</span>
<span style="color:#75715e"># sudo ./hello_world.py</span>

<span style="color:#f92672">from</span> bcc <span style="color:#f92672">import</span> BPF

BPF(src_file <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello_world.c&#34;</span>)
</code></pre></div><p>In order to prevent our script to be killed, it needs to be able to block
signals for multiples pids. I also want to block multiple signals. But how do
we provide this arguments to our eBPF program? This is done using eBPF maps.
Maps are data structures used to share data between userland and our eBPF
program.
There are a lot of different <a href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#maps">kinds of maps</a>,
going from arrays to hashmaps. To create a new map with BCC you use the
<code>BPF_YOURTYPEHERE</code> macro in your C stub like so:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">BPF_HASH(pids, <span style="color:#66d9ef">int</span>, u8); <span style="color:#75715e">// Syntax: BPF_HASH(name, key_type, value_type)
</span></code></pre></div><p>For the eBPF hook, the logic is quite simple: if the given pid is inside the
pids hashmap and the signal is in the signal array, then we need to return early
from the syscall.</p>
<p>Here is the C code corresponding to this algorithm:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;uapi/linux/ptrace.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/sched.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
BPF_HASH(pids, <span style="color:#66d9ef">int</span>, u8);
BPF_ARRAY(sigs, u8, <span style="color:#ae81ff">65</span>);

<span style="color:#66d9ef">static</span> u8 <span style="color:#a6e22e">needs_block</span>(u8 protected_pid, u8 protected_sig) {
    <span style="color:#66d9ef">return</span> protected_pid <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> protected_sig <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">syscall__kill</span>(<span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>ctx, <span style="color:#66d9ef">int</span> pid, <span style="color:#66d9ef">int</span> sig)
{

    u8 <span style="color:#f92672">*</span>protected_pid <span style="color:#f92672">=</span> pids.lookup(<span style="color:#f92672">&amp;</span>pid);
    u8 <span style="color:#f92672">*</span>protected_sig <span style="color:#f92672">=</span> sigs.lookup(<span style="color:#f92672">&amp;</span>sig);
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>protected_pid <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>protected_sig)
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">if</span> (needs_block(<span style="color:#f92672">*</span>protected_pid, <span style="color:#f92672">*</span>protected_sig)) {
        bpf_trace_printk(<span style="color:#e6db74">&#34;Blocked signal %d for %d</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">n&#34;</span>, sig, pid);
        bpf_override_return(ctx, <span style="color:#ae81ff">0</span>);
    }

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>The Python part needs a bit more logic to work:</p>
<ul>
<li>Parse the arguments to retrieve signals to block and the pids that need to be
protected</li>
<li>Add the pid of the Python script</li>
<li>Put the pids to block inside the corresponding maps</li>
</ul>
<p>Here is the Python code (without the argument parsing because that&rsquo;s boring):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Args is the resulting object of parse_args() method of argparse</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">initialize_bpf</span>(args):
    b <span style="color:#f92672">=</span> BPF(src_file<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;blocksig.c&#34;</span>)
    kill_fnname <span style="color:#f92672">=</span> b<span style="color:#f92672">.</span>get_syscall_fnname(<span style="color:#e6db74">&#39;kill&#39;</span>)
    b<span style="color:#f92672">.</span>attach_kprobe(event<span style="color:#f92672">=</span>kill_fnname, fn_name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;syscall__kill&#39;</span>)
    pids_map <span style="color:#f92672">=</span> b<span style="color:#f92672">.</span>get_table(<span style="color:#e6db74">&#39;pids&#39;</span>)
    sigs_map <span style="color:#f92672">=</span> b<span style="color:#f92672">.</span>get_table(<span style="color:#e6db74">&#39;sigs&#39;</span>)

    args<span style="color:#f92672">.</span>pids<span style="color:#f92672">.</span>append(str(os<span style="color:#f92672">.</span>getpid()))
    <span style="color:#66d9ef">for</span> pid <span style="color:#f92672">in</span> args<span style="color:#f92672">.</span>pids:
        pids_map[c_int(int(pid))] <span style="color:#f92672">=</span> c_int(<span style="color:#ae81ff">1</span>)

    <span style="color:#66d9ef">for</span> sig <span style="color:#f92672">in</span> args<span style="color:#f92672">.</span>sig_array:
        sigs_map[sig] <span style="color:#f92672">=</span> c_int(<span style="color:#ae81ff">1</span>)
</code></pre></div><p>Time for a demo:</p>
<pre><code class="language-terminal" data-lang="terminal">$ ping skallwar.fr &gt; /dev/null &amp;
[1] 315629
$ sudo ./blocksig.py 315629 &amp;
$ kill -9 315629
$ # Nothing happened
$ kill -9 $(pidof python) # Pid of the blocksig
$ # Nothing happened
</code></pre><p>But a new problem arises. If the script is protected from signals, and the
terminal in which it runs is closed, we find ourselves unable to stop the
script. In order to do so, I&rsquo;ve implemented a system of ticket (a simple file
with a unique name) in the tmpfs where the script is polling whether our ticket
has been deleted or not:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wait_for_close</span>():
<span style="color:#75715e"># Create a tempfile and wait for its deletion</span>
    tf <span style="color:#f92672">=</span> tempfile<span style="color:#f92672">.</span>NamedTemporaryFile(delete <span style="color:#f92672">=</span> False)
    <span style="color:#66d9ef">print</span>(f<span style="color:#e6db74">&#34;This script might not be killable anymore. To stop it run ``rm {tf.name}``&#34;</span>)

    <span style="color:#66d9ef">try</span>:
        <span style="color:#66d9ef">while</span> os<span style="color:#f92672">.</span>path<span style="color:#f92672">.</span>isfile(tf<span style="color:#f92672">.</span>name):
            time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">0.5</span>)
            <span style="color:#66d9ef">continue</span>
    <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">KeyboardInterrupt</span>:
        tf<span style="color:#f92672">.</span>close()
        os<span style="color:#f92672">.</span>remove(tf<span style="color:#f92672">.</span>name)
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;&#39;</span>)
</code></pre></div><p>So there are 2 use cases:</p>
<ul>
<li>Keep it running in the shell and you can use <code>CTRL+C</code> to raise a Python
keyboard exception (<code>SIGINT</code> can still be blocked)</li>
<li>Run it in the background and use the unique ticket in order to stop it</li>
</ul>
<p>After all of this we should be good, we can protect ourself and our targeted pids.
Let&rsquo;s see what it looks like in htop, just to make sure.</p>
<p>
  <figure class="left" >
    <img src="images/blocksig_py_sudo_pid_problem.png"   />
    
  </figure>



  <figure class="left" >
    <img src="images/here_we_go_again.png"   />
    
  </figure>

</p>
<p>At this stage I was quite frustrated. Yes you could make it work by logging as
root and not using <code>sudo</code> but that&rsquo;s not convenient at all. Fortunately I
found a <a href="https://stackoverflow.com/questions/47284045/switch-user-without-creating-an-intermediate-process">post on stack overflow</a>
about forcing sudo not to fork, suggesting me to use <code>exec</code> before <code>sudo</code>.
And for once, &ldquo;it works on my machine&quot;â„¢ out of the box, nice.</p>
<p>So here is the final result:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;uapi/linux/ptrace.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/sched.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
BPF_HASH(pids, <span style="color:#66d9ef">int</span>, u8);
BPF_ARRAY(sigs, u8, <span style="color:#ae81ff">65</span>);

<span style="color:#66d9ef">static</span> u8 <span style="color:#a6e22e">needs_block</span>(u8 protected_pid, u8 protected_sig) {
    <span style="color:#66d9ef">return</span> protected_pid <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> protected_sig <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">syscall__kill</span>(<span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>ctx, <span style="color:#66d9ef">int</span> pid, <span style="color:#66d9ef">int</span> sig)
{
    u8 <span style="color:#f92672">*</span>protected_pid <span style="color:#f92672">=</span> pids.lookup(<span style="color:#f92672">&amp;</span>pid);
    u8 <span style="color:#f92672">*</span>protected_sig <span style="color:#f92672">=</span> sigs.lookup(<span style="color:#f92672">&amp;</span>sig);
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>protected_pid <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>protected_sig)
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">if</span> (needs_block(<span style="color:#f92672">*</span>protected_pid, <span style="color:#f92672">*</span>protected_sig)) {
        bpf_trace_printk(<span style="color:#e6db74">&#34;Blocked signal %d for %d</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">n&#34;</span>, sig, pid);
        bpf_override_return(ctx, <span style="color:#ae81ff">0</span>);
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#!/usr/bin/python</span>

<span style="color:#f92672">from</span> bcc <span style="color:#f92672">import</span> BPF
<span style="color:#f92672">from</span> bcc.utils <span style="color:#f92672">import</span> ArgString, printb
<span style="color:#f92672">from</span> ctypes <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
<span style="color:#f92672">import</span> argparse
<span style="color:#f92672">import</span> tempfile
<span style="color:#f92672">import</span> time
<span style="color:#f92672">import</span> os

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">parse_args</span>():
    parser <span style="color:#f92672">=</span> argparse<span style="color:#f92672">.</span>ArgumentParser(description<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Blocksig is a tool to block certain or all signal to be recived by given pids&#39;</span>)
    parser<span style="color:#f92672">.</span>add_argument(<span style="color:#e6db74">&#39;-p&#39;</span>, dest<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;pids&#39;</span>, nargs<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;+&#39;</span>, default<span style="color:#f92672">=</span>[], metavar<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;pid&#39;</span>, help<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;List of pid to protect&#39;</span>)
    parser<span style="color:#f92672">.</span>add_argument(<span style="color:#e6db74">&#39;-s&#39;</span>, dest<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;sigs&#39;</span>, nargs<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;+&#39;</span>, default<span style="color:#f92672">=</span>[], metavar<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;signal_num&#39;</span>, help<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;List of signal to block. If no signal is specified, they are all blocked&#39;</span>)
    parser<span style="color:#f92672">.</span>add_argument(<span style="color:#e6db74">&#39;--auto-protect&#39;</span>, action<span style="color:#f92672">=</span>argparse<span style="color:#f92672">.</span>BooleanOptionalAction, default<span style="color:#f92672">=</span>True, help<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Whether to protect blocksig itself or not&#39;</span>)
    args <span style="color:#f92672">=</span> parser<span style="color:#f92672">.</span>parse_args()

    <span style="color:#66d9ef">return</span> args


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">initialize_bpf</span>(args):
    b <span style="color:#f92672">=</span> BPF(src_file <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;blocksig.c&#34;</span>)
    kill_fnname <span style="color:#f92672">=</span> b<span style="color:#f92672">.</span>get_syscall_fnname(<span style="color:#e6db74">&#39;kill&#39;</span>)
    b<span style="color:#f92672">.</span>attach_kprobe(event<span style="color:#f92672">=</span>kill_fnname, fn_name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;syscall__kill&#39;</span>)
    pids_map <span style="color:#f92672">=</span> b<span style="color:#f92672">.</span>get_table(<span style="color:#e6db74">&#39;pids&#39;</span>)
    sigs_map <span style="color:#f92672">=</span> b<span style="color:#f92672">.</span>get_table(<span style="color:#e6db74">&#39;sigs&#39;</span>)

    <span style="color:#66d9ef">if</span> args<span style="color:#f92672">.</span>auto_protect <span style="color:#f92672">==</span> True:
        args<span style="color:#f92672">.</span>pids<span style="color:#f92672">.</span>append(str(os<span style="color:#f92672">.</span>getpid()))
    <span style="color:#66d9ef">for</span> pid <span style="color:#f92672">in</span> args<span style="color:#f92672">.</span>pids:
        pids_map[c_int(int(pid))] <span style="color:#f92672">=</span> c_int(<span style="color:#ae81ff">1</span>)

    sig_array <span style="color:#f92672">=</span> [int(sig) <span style="color:#66d9ef">for</span> sig <span style="color:#f92672">in</span> args<span style="color:#f92672">.</span>sigs] <span style="color:#66d9ef">if</span> len(args<span style="color:#f92672">.</span>sigs) <span style="color:#66d9ef">else</span> range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">64</span>)
    <span style="color:#66d9ef">for</span> sig <span style="color:#f92672">in</span> sig_array:
        sigs_map[sig] <span style="color:#f92672">=</span> c_int(<span style="color:#ae81ff">1</span>)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wait_for_close</span>():
<span style="color:#75715e"># Create a tempfile and wait for its deletion</span>
    tf <span style="color:#f92672">=</span> tempfile<span style="color:#f92672">.</span>NamedTemporaryFile(delete <span style="color:#f92672">=</span> False)
    <span style="color:#66d9ef">print</span>(f<span style="color:#e6db74">&#34;This script might not be killable anymore. To stop it run ``rm {tf.name}``&#34;</span>)

    <span style="color:#66d9ef">try</span>:
        <span style="color:#66d9ef">while</span> os<span style="color:#f92672">.</span>path<span style="color:#f92672">.</span>isfile(tf<span style="color:#f92672">.</span>name):
            time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">0.5</span>)
            <span style="color:#66d9ef">continue</span>
    <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">KeyboardInterrupt</span>:
        tf<span style="color:#f92672">.</span>close()
        os<span style="color:#f92672">.</span>remove(tf<span style="color:#f92672">.</span>name)
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;&#39;</span>)

args <span style="color:#f92672">=</span> parse_args()
initialize_bpf(args)
wait_for_close()
</code></pre></div><p>You can find all the code (and maybe future updates ðŸ‘€) on <a href="https://github.com/Skallwar/blocksig">Github</a></p>
<h1 id="libbpf">Libbpf<a href="#libbpf" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>Before using BCC, I tried to use<a href="https://github.com/libbpf/libbpf"><code>libbpf</code></a>
but it did not work well. Using almost the same C code for the actual eBPF part,
all the syscall arguments had strange values and thus, nothing worked. You can
see what I tried to do on the <a href="https://github.com/Skallwar/blocksig/tree/libbpf">libbpf branch on Github</a></p>
<h1 id="talk">Talk<a href="#talk" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>I have talked about this in a conference for the <a href="https://lse.epita.fr">LSE</a>
(french):

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/oacOs3lQsSs?start=5998" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>
</p>

      </div></div>

  
  
  

  
<script src="https://giscus.app/client.js"
        data-repo="Skallwar/skallwar.fr"
        data-repo-id="MDEwOlJlcG9zaXRvcnkzNTY4MTQyMjU="
        data-category="Posts"
        data-category-id="DIC_kwDOFUSNkc4B-8a_"
        data-mapping="title"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-theme="dark_dimmed"
        crossorigin="anonymous"
        async>
</script>

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">
        <span>Esteban Blanc</span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>





  
</div>

</body>
</html>
